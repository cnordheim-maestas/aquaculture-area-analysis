---
title: "Aquaculture Area Analysis"
author: "Caitlin Nordheim-Maestas"
date: "`r Sys.Date()`"
format: html
---

# 0. Setup

## read in data

```{r}
#| message: false
#| warning: false

library(tidyverse) # data wrangling
library(janitor) # data wrangling
library(sf) # for spatial data
library(tmap) # for pretty maps
library(here) # file pathing
library(viridisLite) # colors
library(patchwork) # combine plots
library(stars) # rasters
library(terra) # rasters

# load in data 

############### SST
# read in each raster, one per year
sst_2008 <- rast(here("data", "average_annual_sst_2008.tif")) 
sst_2009 <- rast(here("data", "average_annual_sst_2009.tif"))
sst_2010 <- rast(here("data", "average_annual_sst_2010.tif"))
sst_2011 <- rast(here("data", "average_annual_sst_2011.tif"))
sst_2012 <- rast(here("data", "average_annual_sst_2012.tif"))

# combine SST rasters into a raster stack
sst <- c(sst_2008, 
         sst_2009, 
         sst_2010, 
         sst_2011, 
         sst_2012)

#assign names to each raster layer
names(sst) <- c("2008", 
         "2009",
         "2010",
         "2011",
         "2012")

############### Bathymetry
# bathymetry raster: depth.tif
bath <- rast(here("data", "depth.tif"))

############### Exclusive Economic Zones
# shapefile for the West Coast EEZ: wc_regions_clean.shp
eez <- st_read(here("data", "wc_regions_clean.shp"), 
               quiet = TRUE) # no message output
```

# 1. Workflow for single species

## 1.2 Process data

### sst

Commented out for a clean output, but here I did data checks and an exploratory map of the layers

```{r}
# data checks
# class(sst) # terra
# crs(sst) # WGS 84

# exploratory vis, commented out

# # quick vis
# # 2008
# sst_2008_map <- tm_shape(sst[["2008"]]) +
#   tm_raster() +
#   tm_title(text = "2008")
# 
# # 2009
# sst_2009_map <- tm_shape(sst[["2009"]]) +
#   tm_raster() +
#   tm_title(text = "2009")
# 
# # 2010
# sst_2010_map <- tm_shape(sst[["2010"]]) +
#   tm_raster() +
#   tm_title(text = "2010")
# 
# # 2011
# sst_2011_map <- tm_shape(sst[["2011"]]) +
#   tm_raster() +
#   tm_title(text = "2011")
# 
# # 2012
# sst_2012_map <- tm_shape(sst[["2012"]]) +
#   tm_raster() +
#   tm_title(text = "2012")

# exploratory vis, commented out
# tmap_arrange(
#   sst_2008_map,
#   sst_2009_map,
#   sst_2010_map,
#   sst_2011_map,
#   sst_2012_map,
#   ncol = 3
# )
```

Now we average the temp over the years and convert to C

```{r}
# local algebra to find the mean sst for each spot
sst_mean <- mean(sst, na.rm = TRUE)

# global algebra to subtract 273.15 to convert from from Kelvin to Celsius
sst_c <- sst_mean - 273.15

# exploratory vis, commented out
# tm_shape(sst_c) +
#   tm_raster() +
#   tm_title(text = "Average sst (C)")
#   tm_layout(legend.outside.position = "right")
```


### get bathymetry to match the sst raster

```{r}
# SAME CRS: data check: ensure same crs
if(crs(bath) == crs(sst_c)) {
  print("coordinate reference systems match")
} else{
  bath <- project(bath, sst_c) 
}

# SAME EXTENT: crop depth raster to match the extent of the SST raster
# crop bathymetry raster to extent of sst_c
bath_crop <- crop(bath, sst_c)

# SAME RESOLUTION: resample to ensure the resolutions match
# using the nearest neighbor approach
# done in discussion section 4
bath_final <- resample(bath_crop, y = sst_c, 
                          method = "near") # for nearest neighbor


# FINAL CHECK: check that the depth and SST match in 
# resolution, extent, and coordinate reference system
# check for extent match
if(ext(bath_final) == ext(sst_c)){
  print("extents match")
} else{
  print("extents do not match")
} # yay

# check for resolution match
if(resolution(bath_final) == resolution(sst_c)){
  print("resolution match")
} else{
  print("resolution do not match")
} # yay

# check for crs
if(crs(bath_final) == crs(sst_c)){
  print("crs match")
} else{
  print("crs do not match")
} # yay

# can the rasters be stacked? Yep!
# sst_bath <- c(bath_final, sst_c)
```

## 1.3 Find suitable locations

Now we will find suitable locations for marine aquaculture in terms of both SST and depth

Remember, oysters can only exist between 11-30 degrees C and -70 through 0 depth.

```{r}
# SST first!
# lets build a matrix
sst_matrix <- matrix(c(-Inf, 11, 0, # from -inf temp to 11, too cold, make a 0
                        11, 30, 1, # good zone! make it 1
                        30, Inf, 0), # from 30 to inf is too hot, make it a 0
                        ncol = 3, byrow = TRUE)
# check the matrix, commented out for clean output
#sst_matrix

# use reclassification matrix to reclassify elevation raster
sst_rcl <- classify(sst_c, rcl = sst_matrix)

# exploratory vis, commented out
# map1 <- tm_shape(sst_c) +
#   tm_raster(col.legend = tm_legend(title = "SST (C)"))+
#   tm_title(text = "original")
# 
# map2 <- tm_shape(sst_rcl) +
#   tm_raster(col.legend = tm_legend(title = "Suitable?"))+
#   tm_title(text= "reclassified")
# 
# tmap_arrange(map1, map2, nrow = 1) 

# Now Depth!
# lets build a matrix
# UPDATE VALUES
bath_matrix <- matrix(c(-Inf, -70, 0, # from -inf to -70 too deep, make a 0
                        -70, 0, 1, # good zone! make it 1
                        0, Inf, 0), # 0 to infinity too high
                        ncol = 3, byrow = TRUE)

# use reclassification matrix to reclassify elevation raster
bath_rcl <- classify(bath_final, rcl = bath_matrix)

# exploratory vis, commented out
# map1 <- tm_shape(bath_final) +
#   tm_raster(col.legend = tm_legend(title = "depth"))+
#   tm_title(text = "original")
# 
# map2 <- tm_shape(bath_rcl) +
#   tm_raster(col.legend = tm_legend(title = "Suitable?"))+
#   tm_title(text= "reclassified")
# 
# tmap_arrange(map1, map2, nrow = 1) 
```

### find locations that satisfy both SST and depth conditions

The SST and depth rasters now identify the suitability of locations as 0 or 1. To find locations that have both suitable temperature and depth, I can use a map algebra trick and mulitply the rasters together. 

Why multiply? anything * 0 = 0 and anything * 1 = itself, so we will end up with only a suitable temp AND depth if it is 1 at the end of the raster math.

```{r}
# determine the suitable cells using the reclassified sst and depth multiplying them
suitable_cells <- sst_rcl * bath_rcl

# make 0's NA
suitable_cells[suitable_cells == 0] <- NA

# exploratory vis, commented out
# map1 <- tm_shape(sst_rcl) +
#   tm_raster(col.legend = tm_legend(title = "Suitable?"))+
#   tm_title(text= "sst")
# map2 <- tm_shape(bath_rcl) +
#   tm_raster(col.legend = tm_legend(title = "Suitable?"))+
#   tm_title(text= "bath")
# map3 <- tm_shape(suitable_cells) +
#   tm_raster(col.legend = tm_legend(title = "Suitable?"))+
#   tm_title(text= "both")
# 
# tmap_arrange(map1, map2, map3, nrow = 1) 
```


## 1.4 Determine the most suitable EEZ

We want to determine the total suitable area within each EEZ. To do so, we need to find the total area of suitable locations within each EEZ.

### check out eez

Exploration of the data, commented out for a clean output

```{r}
# class(eez) # sf dataframe
# colnames(eez) # regions on west coast, their area, and geometry
# st_crs(eez) # WGS 84, good matches the rasters

# exploratory vis, commented out
# map1 <- tm_shape(eez) +
#    tm_basemap("Esri.WorldGrayCanvas") +
#   tm_graticules() +
#   tm_borders() +
# tm_shape(suitable_cells) +
#   tm_raster(col.legend = tm_legend(title = "Suitable?"))
# map1
```


### mask the suitable_cells in west coast

Now we will mask the suitable cells in the west coast by cropping the eez data to the suitable_cells data. We will also rasterize the eez data for downstream analysis.

```{r}
# crs check 
# st_crs(eez) # WGS 84
# crs(suitable_cells) # WGS 84

# crop suitable cells to eez
suitable_cropped <- crop(suitable_cells, eez)

# rasterize eez
eez_rast <- rasterize(eez, suitable_cropped, field = "area_km2")

# exploratory vis, commented out
# map1 <- tm_shape(eez) +
#    tm_basemap("Esri.WorldGrayCanvas") +
#   tm_graticules() +
#   tm_borders() +
# tm_shape(eez_suitable) +
#   tm_raster(col.legend = tm_legend(title = "Suitable?"))
# map1
# 
# map2 <- tm_shape(eez_suitable) +
#   tm_raster(col.legend = tm_legend(title = "Suitable?"))
# map2
```

### find the total suitable area within each EEZ

Now I will calculate the total suitable area for each economic zone using the zonal function, once the cells are in km. I will end up with a dataframe with the suitable area per economic zone

```{r}
# Compute the area covered by individual raster cells in km
suitable_cropped <- cellSize(suitable_cropped, mask=TRUE, lyrs=FALSE, unit="km")

# use zonal stats to get the sum of the area in each eez
zones_suitarea <- terra::zonal(suitable_cropped, # x: SpatRaster
                               eez_rast, # y: needs to be terra object
                               fun = "sum", # sum up the area
                               na.rm = TRUE) # remember to remove NA's!

# update the column names from the initial sf df
zones_annotated <- cbind(eez, zones_suitarea)

# clean the dataframe
zones_clean <- zones_annotated %>%  
  dplyr::select(rgn, area_km2, area) %>% # select columns I care about
  rename("suitable_area" = "area") # rename to something prettier

# class(zones_clean) # "sf" data.frame"
```


## 1.5 map of one species

Here is a draft of the final output map of EEZ regions colored by amount of suitable area for oysters.

```{r}
map <- tm_shape(zones_clean) + # vector data, use tmshape. 
    tm_graticules() + # add graticules at this layer
 
# next layer: fill by area of suitable habitat
  tm_polygons(fill = "suitable_area", # column name with the values
  # specify the color scale, using viridis because it is colorblind friendly
              fill.scale = tm_scale(values =  viridis(2)), 
              fill.legend = tm_legend(title = "Area of suitable habitat (km2)", 
                                      position = tm_pos_out("right"))) +
  
 # next layer: show the outlines of the zones clearly
  tm_borders(col = "black") + # borders of the counties

# add map elements
  tm_title(text = "Suitable habitat for this species in each eez") 

# commented out for a clean output
# map
```

# 2. Generalizable workflow

Let's build the function to encompass all that we've done so far, so we can input data for any species in this area and get a map output.

```{r}
suitable_habitat <- function(bath, # bathymetry raster
                             eez, # eez spatial dataframe
                             sst_c, # raster of sea surface temp; 
                             #with mean sst for the time period you want
                             min_sst, # string with the minimum temp in C
                             max_sst, # string with the max temp in C
                             min_depth_m, # string with the minimum depth in m
                             max_depth_m, # string with the maximum temp in m
                             species_name) # string with species name
  {
#...............STEP 1: Bathymetry raster cleaning...............
  # SAME CRS: project bath to sst_c
       bath <- project(bath, sst_c) 
  # Now crop to same extent: crop bathymetry raster to extent of sst_c
    bath_crop <- crop(bath, sst_c)
  # now ensure in same resolution as sst by resampling, use nearest neighbor
    bath_final <- resample(bath_crop, y = sst_c, 
                          method = "near") # for nearest neighbor

#........STEP 2: build a suitable depth and temp raster.......
    # build a matrix for reclassifying sst
      sst_matrix <- matrix(c(-Inf, min_sst, 0, # from -inf temp to min temp, too cold, make a 0
                        min_sst, max_sst, 1, # good zone! make it 1
                        max_sst, Inf, 0), # from max temp to inf is too hot, make it a 0
                        ncol = 3, byrow = TRUE)
    # use reclassification matrix to reclassify elevation raster
    sst_rcl <- classify(sst_c, rcl = sst_matrix)
  # build a matrix for reclassifying bathymetry
    bath_matrix <- matrix(c(-Inf, max_depth_m, 0, # from -inf to -max_depth_m too deep, make a 0
                        max_depth_m, min_depth_m, 1, # good zone! make it 1
                        min_depth_m, Inf, 0), # min_depth_m to infinity too high
                        ncol = 3, byrow = TRUE)
    # use reclassification matrix to reclassify elevation raster
    bath_rcl <- classify(bath_final, rcl = bath_matrix)
    # determine the suitable cells using the reclassified sst and depth multiplying
    # call the output suitable_cells
    suitable_cells <- sst_rcl * bath_rcl
    # make 0's NA
    suitable_cells[suitable_cells == 0] <- NA

#..........STEP 3: incorporate exclusive economic zones..........    
    # crop suitable cells to eez
    suitable_cropped <- crop(suitable_cells, eez)
    # rasterize eez
    eez_rast <- rasterize(eez, suitable_cropped, field = "area_km2")
    # Compute the area covered by individual raster cells
    suitable_cropped <- cellSize(suitable_cropped, mask=TRUE, lyrs=FALSE, unit="km")
    # use zonal stats
    zones_suitarea <- terra::zonal(suitable_cropped, # x: SpatRaster
                               eez_rast, # y: needs to be terra object
                               fun = "sum", # sum up the area
                               na.rm = TRUE) 
    # update the column names from the initial sf df
     zones <- cbind(eez, zones_suitarea) %>% 
     # clean the dataframe
       dplyr::select(rgn, area_km2, area) %>% # select columns I care about
       rename("suitable_area" = "area") # rename to something prettier
    
#........................STEP 4: Mapping.........................
 map <- tm_shape(zones) + # vector data, use tmshape. 
    tm_graticules() + # add graticules at this layer
 
# next layer: fill by area of suitable habitat
  tm_polygons(fill = "suitable_area", # column name with the values
  # specify the color scale, using viridis because it is colorblind friendly
              fill.scale = tm_scale(values =  viridis(2)), 
              fill.legend = tm_legend(title = "Area of suitable habitat (km2)", 
                                      position = tm_pos_out("right"))) +
  
 # next layer: show the outlines of the zones clearly
  tm_borders(col = "black") + # borders of the counties

# add map elements: title with species name
  tm_title(text = paste0("Suitable habitat for ", species_name))

 # assign name to map
  assign(paste0(species_name, "_map"), map, envir = .GlobalEnv)
}
```

# 3. Output map with generalizable workflow

## Oysters

```{r fig.cap="Figure 1. Map of Exclusive Economic Zones off the West Coast of the USA colored by the amount of suitable habitat area for oysters in square kilometers. The suitable habitat was calculated using the thermal and depth limits of the species."}
#| message: false
#| warning: false
#| fig-height: 10
#| fig-width: 10
oyster_output <- suitable_habitat(bath = bath_final,
                  eez = eez, # eez spatial dataframe
                  sst_c = sst_c, # raster of sea surface temp
                  min_sst = 11, # string with the minimum temp in C
                  max_sst = 30, # string with the max temp in C
                  min_depth_m = 0, # string with the minimum depth in m
                  max_depth_m = -70, # string with the maximum temp in m
                  species_name = "Oyster") # string with species name)
oyster_output
```

## Red Urchin

```{r fig.cap="Figure 2. Map of Exclusive Economic Zones off the West Coast of the USA colored by the amount of suitable habitat area for red urchin (Mesocentrotus franciscanus) in square kilometers. The suitable habitat was calculated using the thermal and depth limits of the species."}
#| message: false
#| warning: false
#| fig-height: 10
#| fig-width: 10

# set parms for the function for the red sea urchin
min_sst <- 4.1
max_sst <- 10.7
min_depth_m <- 0
max_depth_m <- -125
species_name <- " Red Urchin"

# run my function
urchin_output <- suitable_habitat(bath = bath_final,
                  eez = eez, # eez spatial dataframe
                  sst_c = sst_c, # raster of sea surface temp
                  min_sst = min_sst, # string with the minimum temp in C
                  max_sst = max_sst, # string with the max temp in C
                  min_depth_m = min_depth_m, # string with the minimum depth in m
                  max_depth_m = max_depth_m, # string with the maximum temp in m
                  species_name = species_name) # string with species name)
urchin_output
```


