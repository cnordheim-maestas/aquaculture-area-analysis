---
title: "Homework Assignment 4: Prioritizing potential aquaculture"
author: "Caitlin Nordheim-Maestas"
date: "`r Sys.Date()`"
format: html
---

<https://eds-223-geospatial.github.io/assignments/HW4.html>

# 0. Setup

## read in data

```{r}
#| message: false
#| warning: false

library(tidyverse) # data wrangling
library(janitor) # data wrangling
library(sf) # for spatial data
library(tmap) # for pretty maps
library(here) # file pathing
library(viridisLite) # colors
library(patchwork) # combine plots
library(stars) # rasters
library(terra) # rasters

# load in data 

############### SST
# combine SST rasters into a raster stack
# use c() or rast()
# check resolution and extent

sst_2008 <- rast(here("data", "average_annual_sst_2008.tif"))
sst_2009 <- rast(here("data", "average_annual_sst_2009.tif"))
sst_2010 <- rast(here("data", "average_annual_sst_2010.tif"))
sst_2011 <- rast(here("data", "average_annual_sst_2011.tif"))
sst_2012 <- rast(here("data", "average_annual_sst_2012.tif"))

sst <- c(sst_2008, 
         sst_2009, 
         sst_2010, 
         sst_2011, 
         sst_2012)

names(sst) <- c("2008", 
         "2009",
         "2010",
         "2011",
         "2012")

sst

############### Bathymetry
# bathymetry raster: depth.tif
bath <- rast(here("data", "depth.tif"))

############### Exclusive Economic Zones
# shapefile for the West Coast EEZ: wc_regions_clean.shp
eez <- st_read(here("data", "wc_regions_clean.shp"))

```

# 1. Workflow for single species

## 1.2 Process data

### sst

```{r}
# data checks
class(sst) # terra
crs(sst) # WGS 84
names(sst)
summary(sst)

# quick vis
# 2008
sst_2008_map <- tm_shape(sst[["2008"]]) +
  tm_raster() +
  tm_title(text = "2008")

# 2009
sst_2009_map <- tm_shape(sst[["2009"]]) +
  tm_raster() +
  tm_title(text = "2009")

# 2010
sst_2010_map <- tm_shape(sst[["2010"]]) +
  tm_raster() +
  tm_title(text = "2010")

# 2011
sst_2011_map <- tm_shape(sst[["2011"]]) +
  tm_raster() +
  tm_title(text = "2011")

# 2012
sst_2012_map <- tm_shape(sst[["2012"]]) +
  tm_raster() +
  tm_title(text = "2012")

# arrange them in a panel
tmap_arrange(
  sst_2008_map,
  sst_2009_map,
  sst_2010_map,
  sst_2011_map,
  sst_2012_map,
  ncol = 3
)
```

Now we average and convert to C

```{r}
# local algebra to find the mean 
# lapp() or mean()
sst_mean <- lapp(sst, fun = ave) # average function

# global algebra to subtract 273.15 to convert from from Kelvin to Celsius
sst_c <- sst_mean - 273.15

# quick vis
tm_shape(sst_c) +
  tm_raster() +
  tm_title(text = "Average sst (C)")
  tm_layout(legend.outside.position = "right")
```


### get bathymetry to match the sst raster

```{r}
# SAME CRS: data check: ensure same crs
if(crs(bath) == crs(sst_c)) {
  print("coordinate reference systems match")
} else{
  bath <- project(bath, sst_c) 
}

# quick explore
# bath # extent: -132, -114, 29, 50  (xmin, xmax, ymin, ymax)
# sst_c # extent: -131.9848, -114.9867, 29.99305, 49.98842  (xmin, xmax, ymin, ymax)

# SAME EXTENT: crop depth raster to match the extent of the SST raster
# crop bathymetry raster to extent of sst_c
bath_crop <- crop(bath, sst_c)

# SAME RESOLUTION: resample to ensure the resolutions match
# using the nearest neighbor approach
# done in discussion section 4
bath_final <- resample(bath_crop, y = sst_c, 
                          method = "near") # for nearest neighbor

bath_final # coord. ref. : lon/lat WGS 84 (EPSG:4326) 
sst_c # coord. ref. : lon/lat WGS 84 

# FINAL CHECK: check that the depth and SST match in resolution, extent, and coordinate reference system
# hint: can the rasters be stacked?

# check for extent match
if(ext(bath_final) == ext(sst_c)){
  print("extents match")
} else{
  print("extents do not match")
} # not perfect but really close!

# check for resolution match
if(resolution(bath_final) == resolution(sst_c)){
  print("resolution match")
} else{
  print("resolution do not match")
} # yay

# check for crs
if(crs(bath_final) == crs(sst_c)){
  print("crs match")
} else{
  print("crs do not match")
} # yay

# can the rasters be stacked? Yep!
# sst_bath <- c(bath_final, sst_c)
```

## 1.3 Find suitable locations

Find suitable locations for marine aquaculture, we’ll need to find locations that are suitable in terms of both SST and depth

Remember, oysters can only exist between 11-30 degrees C and -70 through 0 depth. Set suitable values to 1 and unsuitable values to 0

Matrix we will build for temp
-Inf, 11, 0 # we want this to be a zero
11, 30, 1 # we want this to be a one
30, Inf, 0 # we want this to be a zero

Matrix we will build for depth
-Inf, -70, 0 # we want this to be a zero
-70, 0, 1 # we want this to be a one
0, Inf, 0 # we want this to be a zero

Hint check out week 4 lab


```{r}
# SST first!
# lets build a matrix
sst_matrix <- matrix(c(-Inf, 11, 0, # from -inf temp to 11, too cold, make a 0
                        11, 30, 1, # good zone! make it 1
                        30, Inf, 0), # from 30 to inf is too hot, make it a 0
                        ncol = 3, byrow = TRUE)

sst_matrix

# use reclassification matrix to reclassify elevation raster
sst_rcl <- classify(sst_c, rcl = sst_matrix)

# quick vis of what we just did
map1 <- tm_shape(sst_c) +
  tm_raster(col.legend = tm_legend(title = "SST (C)"))+
  tm_title(text = "original")

map2 <- tm_shape(sst_rcl) +
  tm_raster(col.legend = tm_legend(title = "Suitable?"))+
  tm_title(text= "reclassified")

tmap_arrange(map1, map2, nrow = 1) 
```



```{r}
# Now Depth!
# lets build a matrix
# UPDATE VALUES
bath_matrix <- matrix(c(-Inf, -70, 0, # from -inf to -70 too deep, make a 0
                        -70, 0, 1, # good zone! make it 1
                        0, Inf, 0), # 0 to infinity too high
                        ncol = 3, byrow = TRUE)

# use reclassification matrix to reclassify elevation raster
bath_rcl <- classify(bath_final, rcl = bath_matrix)

# quick vis of what we just did
map1 <- tm_shape(bath_final) +
  tm_raster(col.legend = tm_legend(title = "depth"))+
  tm_title(text = "original")

map2 <- tm_shape(bath_rcl) +
  tm_raster(col.legend = tm_legend(title = "Suitable?"))+
  tm_title(text= "reclassified")

tmap_arrange(map1, map2, nrow = 1) 
```


### find locations that satisfy both SST and depth conditions

Tip: The SST and depth rasters should now identify the suitability of locations as 0 or 1. To find locations that have both suitable temperature and depth, you can use map algebra. 

Why multiply? anything * 0 = 0 and anything * 1 = itself, so we will end up with only a suitable temp AND depth if it is 1.

```{r}
# determine the suitable cells using the reclassified sst and depth multiplying them, call the output suitable_cells
suitable_cells <- sst_rcl * bath_rcl

# make 0's NA
suitable_cells[suitable_cells == 0] <- NA

# visualize what we just did
map1 <- tm_shape(sst_rcl) +
  tm_raster(col.legend = tm_legend(title = "Suitable?"))+
  tm_title(text= "sst")
map2 <- tm_shape(bath_rcl) +
  tm_raster(col.legend = tm_legend(title = "Suitable?"))+
  tm_title(text= "bath")
map3 <- tm_shape(suitable_cells) +
  tm_raster(col.legend = tm_legend(title = "Suitable?"))+
  tm_title(text= "both")

tmap_arrange(map1, map2, map3, nrow = 1) 
```


## 1.4 Determine the most suitable EEZ

We want to determine the total suitable area within each EEZ in order to rank zones by priority. To do so, we need to find the total area of suitable locations within each EEZ.

### check out eez

```{r}
class(eez) # sf dataframe
colnames(eez) # regions on west coast, their area, and geometry
st_crs(eez) # WGS 84, good matches the rasters

# quick vis
map1 <- tm_shape(eez) +
   tm_basemap("Esri.WorldGrayCanvas") +
  tm_graticules() +
  tm_borders() +
tm_shape(suitable_cells, bbox = eez_bbox) +
  tm_raster(col.legend = tm_legend(title = "Suitable?"))
map1
```


### mask the suitable_cells in west coast

```{r}
# crs check 
# st_crs(eez) # WGS 84
# crs(suitable_cells) # WGS 84

# crop suitable cells to eez
suitable_cropped <- crop(suitable_cells, eez)

# select suitable cells within West Coast EEZs, mask eez by suitable cells
eez_suitable <- mask(suitable_cropped, eez) # create a new SpatRaster that has the same values as SpatRaster x except for cells in y that are NA

# now the suitable areas are cropped to the west coast eez only
map1 <- tm_shape(eez) +
   tm_basemap("Esri.WorldGrayCanvas") +
  tm_graticules() +
  tm_borders() +
tm_shape(eez_suitable) +
  tm_raster(col.legend = tm_legend(title = "Suitable?"))
map1

# rasterize?
suitable_zones <- rasterize(eez, suitable_cells, field = "area_km2")
suitable_zones

# now mask?
eez_suitable <- mask(suitable_cells, suitable_zones)
eez_suitable

map1 <- tm_shape(eez_suitable) +
  tm_raster(col.legend = tm_legend(title = "Suitable?"))
map1
```

find area of grid cells


In discussion today?

Zonal algebra (x, y)

x is raster, y needs to be a terra object (spatVector or a raster)

extract()

count grid cells

cellsize()

zonal_output --> eez


### find the total suitable area within each EEZ

hint: it might be helpful to rasterize the EEZ data


```{r}
zones_suitarea <- terra::zonal(suitable_cells, suitable_zones, fun = "sum") # unclear on what to input here
zones_annotated <- cbind(eez, zones_suitarea)

# clean the df for funsies
zones_clean <- zones_annotated  %>%  
  dplyr::select(rgn, area_km2, area_km2.1) %>% 
  rename("suitable_area" = "area_km2.1") 

class(zones_clean) # "sf"         "data.frame"
```


## 1.5 map of one species

map of EEZ regions colored by amount of suitable area
species name should be included in the map’s title

Here is a draft of the final output map

```{r}
map <- tm_shape(zones_clean) + # vector data, use tmshape. 
    tm_graticules() + # add graticules at this layer
 
# next layer: fill by area of suitable habitat
  tm_polygons(fill = "suitable_area", # column name with the values
  # specify the color scale, using viridis because it is colorblind friendly
              fill.scale = tm_scale(values =  viridis(2)), 
              fill.legend = tm_legend(title = "Area of suitable habitat (km2)", 
                                      position = tm_pos_out("right"))) +
  
 # next layer: show the outlines of the zones clearly
  tm_borders(col = "black") + # borders of the counties

# add map elements
  tm_title(text = "Suitable habitat for this species in each eez") 

map
```

# 2. Generalizable workflow

Note: per species info like min_sst, max_sst min_depth and max_depth will be parms

# 3. Output map with generalizable workflow


